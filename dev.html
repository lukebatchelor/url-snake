<body>
    <script>
      let d = document,
        b = d.body,
        M = Math,
        body = `<meta name="viewport" content="width=device-width,initial-scale=1" />Space: start/reset. Arrows: Move<div><canvas id=a><style>#a{border:solid;width:80vmin}*{background:tan;display:flex;flex-direction:column;align-items:center;font-size:1.2rem;}</style>`,
        gridSize = 40,
        canvasSize = 400,
        w = canvasSize/gridSize,
        // let alive initialise itself to undefined which is falsy
        alive,
        // don't worry about initialising score, heading, etc, we'll reset on start
        score,
        defaultSnake = 3+3*3,
        snake = [defaultSnake],
        // valid array key codes
        headings = [-1,-w,1,w],
        // heading stores the current heading key code - 38
        // -1=left, 0=up, 1=right, 2=down
        heading,
        // default the fruit to the pos of the snakes tail to save a coord
        fruit = snake[0],
        black = "#000",
        red = "red",
        tmp,
        addEventListener = "addEventListener",
        rect = (xy, col = black, sz = gridSize) => {
          (ctx.fillStyle = col), ctx.fillRect((xy%w) * gridSize, ((xy/w)|0)*gridSize, sz, sz);
        },
        text = (str, x, y = x, align = "center") => {
          ctx.fillStyle = black;
          ctx.textAlign = align;
          ctx.fillText(str, x, y);
        },
        update = () => {
          if (!alive) return;
          let nextXY = snake[0] + heading,
            collides = xy => xy == nextXY;
          // remove current tail
          snake.pop();
          // check death
          if (
              nextXY < 0 || nextXY >= w*w ||
              (M.abs(heading)==1 && (nextXY/w|0) - ((nextXY-heading)/w|0)) ||
              snake.some(collides)
          )
            return die();
          // and increment the new head
          snake.unshift(nextXY);
          // check fruit
          if (collides(fruit)) {
            // make a copy of the tail, using the score as a proxy for snake.length-1
            snake.push(snake[score++]);
            fruit = (M.random()*w*w)|0;
          }
          // clear screen
          rect(0, "tan", canvasSize);
          // draw snake
          snake.map(s=>rect(s)); 
          // draw fruit
          rect(fruit, red);
          // draw score
          text(score, 9, 30, "left");
        },
        die = () => {
          alive = 0;
          rect(0, red, canvasSize);
          // rely on default y position and text align
          text(":(", canvasSize / 2);
        },
        reset = () => {
          (alive = 1),
            (snake = [defaultSnake]),
            (heading = 1), // heading = 40 - 38
            (score = 0);
        };
      b.innerHTML = body;
      let ctx = a.getContext("2d");
      // a is the id of the injected canvas, available globally
      a.height = a.width = canvasSize;
      // invalid font family defaults to auto
      ctx.font = "30px f";
      // minifier willl minify these names correctly
      tmp = a.getBoundingClientRect();
      d[addEventListener]("keyup", ({ which: w }) =>  headings[w-37] && (heading=headings[w-37]) || w == 32 && !alive && reset());
      a[addEventListener]("touchstart", ({ touches: [{ clientX, clientY }] }) => {
        if (!alive) reset();
        const [touchX, touchY] = [clientX - tmp.x,clientY - tmp.y].map(v => v*3);
        heading = headings[[touchY < tmp.height, 
        touchY > tmp.height * 2,
        touchX < tmp.width,
        touchX > tmp.width * 2].findIndex(_=>_)] || heading;
      });
      // if key is space and we're dead, reset. Otherwise, check if key is a valid
      // arrow key and store that key - 38 (saves a couple of bytes calculating later)
      setInterval(update, canvasSize);
    </script>
  
