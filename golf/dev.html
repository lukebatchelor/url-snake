<body>
  <script>
    let b = document.body,
      body = `Space: start/reset. Arrows: Move<div><canvas id=a><style>#a{border:solid}*{background:tan}</style>`,
      gridSize = 40,
      canvasSize = 400,
      sz = 10,
      // let alive initialise itself to undefined which is falsy
      alive,
      // don't worry about initialising score, heading or ctx, we'll let them get set globally on use
      // though the minifier wont automatically mangle their names, so we have to make them short ourselves
      // score,   // S
      H,
      y = v=>v/sz|0,
      // ctx,     // C
      snake = [34],
      // our current direction 
      // default the fruit to the pos of the snakes tail to save a coord
      fruit = snake[0],
      black = "#000",
      // we automatically times the x and y by gridsize since the all the places
      // that draw rects either need it, or they're passing 0,0. Use a bunch of
      // default values to allow super short screen clearing
      rect = (col = "red", size = canvasSize, xy = 0) => {
        // set a global fillStyle var so we can use it again in the text fn
        (C[(f = "fillStyle")] = col),
          C.fillRect((xy%sz) * gridSize, y(xy)*gridSize, size, size);
      },
      text = (str, x = canvasSize / 2, y = x, align = "center") => {
        C[f] = black;
        C.textAlign = align;
        C.fillText(str, x, y);
      };
    b.innerHTML = body;
    C = a.getContext`2d`;
    // a is the id of the injected canvas, available globally
    a.height = a.width = canvasSize;
    // invalid font family defaults to auto
    C.font = "30px f";
    b.onkeyup = ({ which: w }) => 
      // check if key is arrow key. 0=up,1=right,2=down,-1=left
      (w == 32 &&         // otherwise, if it was a space and we are dead
          !alive &&
          ((alive = 1),
          (snake = [34]),
          (H = sz),     // heading = 40 - 38 = down
          (S = 0))) ||
      (H = [-1,-sz,1,sz][w-37] || H); 
    
    setInterval((fakeVar) => {
      if (!alive) return;
      const next  = snake[0] + H;
      snake.pop();    // remove current tail
      if (           // check out of bounds and self collision
        next < 0 || next > 99 ||
        (H&1 && y(next) - y(next-H)) ||
        snake.includes(next)
      )
        return (  
          (alive = 0),  // inlined death fn
          rect(),       // completely rely on default values to clear whole screen red
          text`:(`     // rely on default y position and text align
        );
      // add back our new head by making a new copy since it's shorter than unshift
      snake.unshift(next);
      // check fruit collision
        // make a copy of the tail, using the pre-incremented score as a pointer
        // to snake.length ðŸ¤¯
      (!(next-fruit)) &&
      (snake[++S]=snake[S-1]) &&
      (fruit = 255*97*S%(sz*sz));
      // clear screen relying on default args and tagged template strings
      rect`tan`;
      // draw snake
      snake.map(pos => rect(black, gridSize,pos))
      // draw fruit
      rect(fakeVar, gridSize, fruit);
      // draw score
      text(S, 9, 30, "left");
    }, canvasSize);
  </script>
